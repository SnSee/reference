
# python常用模块

## os

### os.path

```python
# 将参数中开头部分的 ~ 或 ~user 替换为对应用户的家目录
os.path.expanduser('~/test')
os.path.expanduser('~yin/test')

# 将参数中的环境变量名替换为变量值($name ${name})，windows上还支持 %name%
os.environ['TEST'] = 'test_value'
os.path.expandvars('$TEST')
os.path.expandvars('${TEST}')
os.path.expandvars('%TEST%')
```

### 时间戳

```python
# 比较时间戳
time_new = os.stat(newFile).st_mtime
time_old = os.stat(oldFile).st_mtime
assert time_new > time_old
```

## threading

基础用法

```python
from threading import Thread

def func(a, b, c):
    print(a, b, c)

def call():
    t1 = Thread(target=func, args=(1, 2, 3))
    t2 = Thread(target=func, args=('a', 'b', 'c'))
    t1.start()
    t2.start()
    t1.join()
    t2.join()
    print("over")
```

定时器

```python
import threading

lock = threading.Lock()

def keep_run():
    print("keep run")
    lock.acquire()
    _timer = threading.Timer(1, keep_run)
    _timer.start()
    lock.release()


def once_run():
    print("once run")


if __name__ == '__main__':
    timer = threading.Timer(1, function=once_run)
    # timer = threading.Timer(1, function=keep_run)
    timer.start()
    # timer.cancel()
```

自动释放线程锁

```python
import threading

lock = threading.Lock()

def func():
    with lock:
        # execute code that needs to be locked
        pass # do something here
```

## types

区别函数和方法(是否是static)

```python
# 方式一
isinstance(func, types.FunctionType)    # 普通函数，类静态函数
isinstance(func, types.MethodType)      # 普通类方法，cls类方法

# 方式二
t = Test()
inspect.isfunction(t.f)     # 普通函数，类静态函数(只能使用对象)
inspect.ismethod(t.f)       # 普通类方法，cls类方法(只能使用对象)
```

## inspect

获取函数调用栈

```python
# 获取调用栈列表，0索引为当前函数，1索引为上一级函数
# list[inspect.FrameInfo]
inspect.stack()

# 根据函数对象获取其所在文件路径
inspect.getfile(func)
```

获取函数签名

```python
sig = inspect.signature(func)   # 获取函数签名对象
# 添加函数注解时value会有类型信息，如果参数可以是多种类型需要使用 | 或 Union，不能使用 or
sig.parameters          # 参数列表对象(OrderedDict类型)，key是形参名称
sig.return_annotation   # 返回值类型，只有添加函数注解才有

# 绑定形参(实质是创建以形参为key，绑定对象为value的dict)
sb = sig.bind(obj1, obj2)    # 个数必须和func的位置参数个数一样
sb = sig.bind_partial(obj1)  # 只绑定前面的位置参数
sb.argument     # 绑定后的dict
```

## re

match

```python
input_str = 'Tom 18'

# 方式一
pattern = r'(\w+)\s+(\d+)'
ret: typing.Optional[re.Pattern] = re.match(pattern, input_str)
if ret:
    print('name:', ret.group(1))
    print(' age:', ret.group(2))

# 方式二
namePat = re.compile(r'(\w+)\s+(\d+)')
ret: typing.Optional[re.Pattern] = re.match(input_str)
```

search

```python
input_str = 'name Tom 18, Jerry 16, sth else'

# 方式一
pattern = r'(\w+)\s+(\d+)'
ret: typing.Optional[re.Pattern] = re.search(pattern, input_str)
if ret:
    print('name:', ret.group(1))
    print(' age:', ret.group(2))

# 方式二
namePat = re.compile(r'(\w+)\s+(\d+)')
ret: typing.Optional[re.Pattern] = re.search(input_str)
```

findall

```python
# 输入的字符串
input_str = 'my age is 18, and my height is 175cm'
# 定义正则表达式，并编译为Pattern对象
pattern = re.compile(r'\d+')
# 使用Pattern对象匹配字符串，返回一个包含所有匹配结果的列表
result_list: list[str] = pattern.findall(input_str)
# 打印匹配结果列表
print(result_list)
```

tips

```text
match   匹配时会从字符串头开始匹配，如果有不符合的就匹配不上
search  只要字符串中任意子串能匹配上即可，返回第一个匹配的字串
```

## fnmatch

通配符匹配，类似于shell的通配符
fnmatch 函数不区分大小写
fnmatchcase 区分大小写
函数返回值为bool类型

|特殊格式 |含义
|:-- | :-- |
|*          | 零个或任意多个字符
|?          | 任意一个字符
|[adf]      | 方括号中任意一个字符
|[a-zA-Z]   | 任意英文字符

```python
from fnmatch import fnmatch, fnmatchcase

fnmatch('test.txt', 'test*')                # True
fnmatch('test.txt', '*.txt')                # True
fnmatch('test.txt', '[sT]est.txt')          # True
fnmatch('test.txt', '[A-Z]est.txt')         # True
fnmatchcase('test.txt', '[sT]est.txt')      # False
fnmatchcase('test.txt', '[A-Z]est.txt')     # False
fnmatchcase('test.txt', '[a-zA-Z]est.txt')  # True
```

## glob

glob采用通配符模式匹配文件，默认不会递归查找

```python
import glob

# 查找当前目录下所有的txt文件
txt_files: list[str] = glob.glob('*.txt')
print(txt_files)

# 在指定路径下查找所有的txt文件
txt_files = glob.glob('/path/to/directory/*.txt')

# 递归地查找指定目录及其子目录下所有的txt文件
# 无论子目录层级有多深都会查找
txt_files = glob.glob('/path/to/directory/**/*.txt', recursive=True)
```
