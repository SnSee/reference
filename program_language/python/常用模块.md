
# python常用模块

## os

### os.path

```python
# 将参数中开头部分的 ~ 或 ~user 替换为对应用户的家目录
os.path.expanduser('~/test')
os.path.expanduser('~yin/test')

# 将参数中的环境变量名替换为变量值($name ${name})，windows上还支持 %name%
os.environ['TEST'] = 'test_value'
os.path.expandvars('$TEST')
os.path.expandvars('${TEST}')
os.path.expandvars('%TEST%')
```

进程

```python
# 获取当前进程id
os.getpid()

# 向进程发送信号
os.kill(pid, signal.SIGKILL)
```

### 时间戳

```python
# 比较时间戳
time_new = os.stat(newFile).st_mtime
time_old = os.stat(oldFile).st_mtime
assert time_new > time_old
```

## threading

基础用法

```python
from threading import Thread

def func(a, b, c):
    print(a, b, c)

def call():
    t1 = Thread(target=func, args=(1, 2, 3))
    t2 = Thread(target=func, args=('a', 'b', 'c'))
    t1.start()
    t2.start()
    # timeout后主线程不再等待子线程结束, 继续向下运行(子线程仍在运行)
    t1.join(timeout=5)
    t2.join(timeout=5)

    # 获取指定线程id
    print(t1.ident)
    print("over")
```

线程id

```python
# 获取当前线程id
threading.get_ident()

# 获取指定线程id
Thread.ident
```

守护线程

> 1. 将线程设置为守护线程: 在 Thread.start 前调用 **Thread.daemon = True** 或 Thread.setDaemon(True)
> 2. python 主程序 **会** 等待所有**非**守护线程退出后才会退出, **不会** 等待守护线程退出
> 3. python 主程序退出时会 **终止** 所有守护线程
> 4. 线程默认是 **非** 守护的
> 5. 新的子线程会继承 父线程 的守护状态

强制杀死子线程

```python
import signal
# 主程序强制结束, 所有线程都会被杀死
signal.pthread_kill(Thread.ident, signal.SIGKILL)

# 冻结指定线程，主线程退出时该线程会被杀死
# 测试时会强制退出而不是冻结
signal.pthread_kill(Thread.ident, signal.SIGSTOP)
# 恢复冻结线程
signal.pthread_kill(Thread.ident, signal.SIGCONT)
```

定时器

```python
import threading

lock = threading.Lock()

def keep_run():
    print("keep run")
    lock.acquire()
    _timer = threading.Timer(1, keep_run)
    _timer.start()
    lock.release()


def once_run():
    print("once run")


if __name__ == '__main__':
    timer = threading.Timer(1, function=once_run)
    # timer = threading.Timer(1, function=keep_run)
    timer.start()
    # timer.cancel()
```

自动释放线程锁

```python
import threading

lock = threading.Lock()

def func():
    with lock:
        # execute code that needs to be locked
        pass # do something here
```

线程池

```python
import threading
from concurrent.futures import ThreadPoolExecutor

# 定义要执行的任务
def do_task(task_id):
    # 获取锁
    with _lock:
        print(f"in task: {task_id}")

# 创建线程池和锁对象
pool = ThreadPoolExecutor(max_workers=4)
_lock = threading.Lock()

# 提交多个任务到线程池
for i in range(10):
    pool.submit(do_task, i)

# 等待所有任务完成
# 注意：子线程中如果抛出异常不会自动捕获也不会处理，
#       可以自己保证子线程不会抛出异常，或者使用下面的 result() 函数处理
pool.shutdown(wait=True)
```

```python
import concurrent.futures

# 创建一个线程池
with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
    # 提交多个任务到线程池中
    future_tasks = [executor.submit(do_task, i) for i in range(10)]

    # 等待所有任务完成
    for future in concurrent.futures.as_completed(future_tasks):
        # 对每个任务的结果进行处理
        try:
            result = future.result()
        except:
            pass

    # 所有任务完成后，关闭线程池
    executor.shutdown()
```

## types

区别函数和方法(是否是static)

```python
# 方式一
isinstance(func, types.FunctionType)    # 普通函数，类静态函数
isinstance(func, types.MethodType)      # 普通类方法，cls类方法

# 方式二
t = Test()
inspect.isfunction(t.f)     # 普通函数，类静态函数(只能使用对象)
inspect.ismethod(t.f)       # 普通类方法，cls类方法(只能使用对象)
```

## inspect

获取函数调用栈

```python
# 获取调用栈列表，0索引为当前函数，1索引为上一级函数
# list[inspect.FrameInfo]
inspect.stack()

# 根据函数对象获取其所在文件路径
inspect.getfile(func)
```

获取函数签名

```python
sig = inspect.signature(func)   # 获取函数签名对象
# 添加函数注解时value会有类型信息，如果参数可以是多种类型需要使用 | 或 Union，不能使用 or
sig.parameters          # 参数列表对象(OrderedDict类型)，key是形参名称
sig.return_annotation   # 返回值类型，只有添加函数注解才有

# 绑定形参(实质是创建以形参为key，绑定对象为value的dict)
sb = sig.bind(obj1, obj2)    # 个数必须和func的位置参数个数一样
sb = sig.bind_partial(obj1)  # 只绑定前面的位置参数
sb.argument     # 绑定后的dict
```

## re

match

```python
input_str = 'Tom 18'

# 方式一
pattern = r'(\w+)\s+(\d+)'
ret: typing.Optional[re.Pattern] = re.match(pattern, input_str)
if ret:
    print('name:', ret.group(1))
    print(' age:', ret.group(2))

# 方式二
namePat = re.compile(r'(\w+)\s+(\d+)')
ret: typing.Optional[re.Pattern] = re.match(input_str)
```

search

```python
input_str = 'name Tom 18, Jerry 16, sth else'

# 方式一
pattern = r'(\w+)\s+(\d+)'
ret: typing.Optional[re.Pattern] = re.search(pattern, input_str)
if ret:
    print('name:', ret.group(1))
    print(' age:', ret.group(2))

# 方式二
namePat = re.compile(r'(\w+)\s+(\d+)')
ret: typing.Optional[re.Pattern] = re.search(input_str)
```

findall

```python
# 输入的字符串
input_str = 'my age is 18, and my height is 175cm'
# 定义正则表达式，并编译为Pattern对象
pattern = re.compile(r'\d+')
# 使用Pattern对象匹配字符串，返回一个包含所有匹配结果的列表
result_list: list[str] = pattern.findall(input_str)
# 打印匹配结果列表
print(result_list)
```

tips

```text
match   匹配时会从字符串头开始匹配，如果有不符合的就匹配不上
search  只要字符串中任意子串能匹配上即可，返回第一个匹配的字串
```

## fnmatch

通配符匹配，类似于shell的通配符
fnmatch 函数不区分大小写
fnmatchcase 区分大小写
函数返回值为bool类型

|特殊格式 |含义
|:-- | :-- |
|*          | 零个或任意多个字符
|?          | 任意一个字符
|[adf]      | 方括号中任意一个字符
|[a-zA-Z]   | 任意英文字符

```python
from fnmatch import fnmatch, fnmatchcase

fnmatch('test.txt', 'test*')                # True
fnmatch('test.txt', '*.txt')                # True
fnmatch('test.txt', '[sT]est.txt')          # True
fnmatch('test.txt', '[A-Z]est.txt')         # True
fnmatchcase('test.txt', '[sT]est.txt')      # False
fnmatchcase('test.txt', '[A-Z]est.txt')     # False
fnmatchcase('test.txt', '[a-zA-Z]est.txt')  # True
```

## glob

glob采用通配符模式匹配文件，默认不会递归查找

```python
import glob

# 查找当前目录下所有的txt文件
txt_files: list[str] = glob.glob('*.txt')
print(txt_files)

# 在指定路径下查找所有的txt文件
txt_files = glob.glob('/path/to/directory/*.txt')

# 递归地查找指定目录及其子目录下所有的txt文件
# 无论子目录层级有多深都会查找
txt_files = glob.glob('/path/to/directory/**/*.txt', recursive=True)
```

## profile

profile是Python标准库中的一个性能分析工具，通过在代码中添加适当的装饰器或者命令行参数，可以对程序进行分析，找出其中的瓶颈，从而进行优化。

```text
profile模块输出的性能分析结果，通常包括以下几列信息：

ncalls          ：函数调用次数。
tottime         ：函数总耗时（不包括调用其他函数的时间）
percall         ：函数平均耗时，即 tottime/ncalls
cumtime         ：函数总耗时（包括调用其他函数的时间）
percall         ：函数平均耗时，即 cumtime/ncalls。
filename:lineno(function)：函数所在的文件名、行号和函数名。如果是内置函数，则只有函数名。
```

<!-- markdownlint-disable-next-line no-emphasis-as-heading -->
**代码方式**

```python
import profile
import cProfile
import pstats

def increase():
    s = ''
    while len(s) < 100 * 100:
        s += 'a'

if __name__ == "__main__":
    cProfile.run("increase()", "result.prof")
    # profile 完全由python实现，filename显示效果与 cProfile 不同
    # profile.run("increase()", "result.prof")
    pstats.Stats('result.prof').sort_stats('cumtime').print_stats()
```

```python

# 指定多种排序方式
# 首先按照总耗时排序，然后按照函数调用次数排序
sort_stats('cumulative', 'calls') 

# 只显示前十条
print_states(10)

# 只显示前50%
print_states(0.5)
```

指定排序方式

```text
sort_stats 可根据接收参数指定排序方式：

calls/ncalls    ：函数调用次数
tottime         ：总耗时（不 包括子函数调用耗时）
cumtime         ：总耗时（包括子函数调用耗时）
file            ：文件名
filename        ：文件名
module          ：模块名
pcalls          ：平均调用耗时
line            ：行号
name            ：函数名
nfl             ：文件名和行号
stdname         ：标准函数名
```

**命令行** 方式

profile模块提供了一个可执行的命令行工具cProfile，可以直接在命令行中使用。

```bash
# 运行脚本并统计函数耗时
# 由于显示函数过多，可以使用grep进行过滤
python -m cProfile my_script.py

# 可以使用-s参数指定排序方式
python -m cProfile -s cumtime my_script.py

# 此外，还可以使用-o参数将性能分析结果输出到一个文件中，然后使用pstats模块进行分析
python -m cProfile -o my_script.prof my_script.py

# 进入pstats命令行
python -m pstats my_script.prof
```

pstats命令行命令

```prof
# 读取cProfile输出文件
read <prof>

# 排序
sort cumtime
# 简化显示
strip

# 查看耗时
stats
# 只查看前五条
stats 5
```

## asyncio

[官方文档](https://docs.python.org/zh-cn/3.10/library/asyncio-task.html)

> asyncio 是标准库中的一个异步 IO 库，它提供了一种基于 **协程**（coroutine）和 **事件循环**（event loop）的方式来处理 IO 操作。相比于传统的多线程或多进程模型，asyncio 通过 **单线程** **非阻塞** 的方式来支持大量并发连接，从而提高了应用程序的性能和响应性。
>
> 以下是 asyncio 的主要特点：
>
> 1. 协程：协程是一种轻量级的子程序，可以在同一线程内进行切换。
> 2. 事件循环：异步 IO 的核心，它充当着调度器的角色，负责管理所有协程的执行。事件循环不断地从任务队列里取出一个协程运行，并在协程阻塞时切换到其他可运行的协程，从而实现了高效率的并发处理。
> 3. 异步模块和函数：asyncio 提供了很多异步的网络 IO 模块和函数，包括 TCP、UDP、SSL、HTTP、WebSocket 等。使用这些模块和函数，开发者可以非常方便地编写网络 IO 代码，避免繁琐的回调函数和线程同步问题。
> 4. 兼容性：asyncio 支持 Python 3.4 及以上版本，可以运行在 Windows、Mac OS 和 Linux 等多种操作系统上，并且与其他异步框架如 Tornado 和 aiohttp 可以很好地兼容。

和线程比较

> 对于IO密集型任务，协程更适合；对于CPU密集型任务，线程更适合。
>
> 1. 调度   : 协程由事件循环调度器调度(在用户态)；线程由操作系统调度(切换线程在内核态进行)。
> 2. 上下文 : 协程只涉及CPU? 线程包括CPU，线程私有函数栈？
> 3. 开销   : 由于1，2，协程开销比线程小。
> 4. 维护性 : 协程代码比线程复杂，线程需要线程同步。
> 5. 多核   : 协程无法利用多核CPU；线程可以利用。

基础用法

```python
import asyncio

async def async_test(delay: int):
    print('enter', delay)
    await asyncio.sleep(delay)
    print('exit', delay)

async def make_tasks() -> list[asyncio.Task]:
    tasks = [
        # 创建Task时协程就已经进入事件循环了
        asyncio.create_task(async_test(1)),
        asyncio.create_task(async_test(2))
    ]
    return tasks

# 不等待协程结束，退出时未执行完成的协程会被杀死
async def no_wait():
    print("no wait start")
    await make_tasks()
    print("no wait end")

# 不等待协程，但是主程序睡眠，退出时未执行完成的协程会被杀死
async def no_wait_sleep():
    print("no wait sleep start")
    await make_tasks()
    # 主程序睡眠（其他协程仍在运行）
    await asyncio.sleep(3)
    print("no wait sleep end")

# 等待单个协程结束，退出时未执行完成的协程会被杀死
async def wait_one():
    print("wait one start")
    tasks = await make_tasks()
    await tasks[0]
    print("wait one end")

# 等待所有协程结束
async def wait_all():
    print("wait all start")
    tasks = await make_tasks()
    await asyncio.wait(tasks)
    print("wait all end")

async def main():
    print("***********************")
    await no_wait()
    print("***********************")
    await no_wait_sleep()
    print("***********************")
    await wait_one()
    print("***********************")
    await wait_all()
    print("***********************")

asyncio.run(main())
```

设置等待超时

```python
import asyncio

async def sleep():
    print("coroutine enter")
    await asyncio.sleep(100)
    print("coroutine exit")

async def main():
    try:
        await asyncio.wait_for(sleep(), timeout=1)
    except asyncio.TimeoutError:
        print("timeout ...")

asyncio.run(main())
```

asyncio.wait设置返回策略

```python
await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)

# FIRST_COMPLETED               ：等待任意一个任务完成，然后返回结果
# FIRST_EXCEPTION               ：等待第一个抛出异常的任务，并将异常抛出
# ALL_COMPLETED                 ：等待全部任务完成后返回结果，不管它们是否成功
# LAST_COMPLETED                ：等待最后一个任务完成后返回结果
# FIRST_COMPLETED_OR_EXCEPTION  ：等待第一个完成或引发异常的任务，然后返回结果或抛出异常

# 当使用 FIRST_EXCEPTION 或 FIRST_COMPLETED_OR_EXCEPTION 等策略时，应该使用
# await asyncio.gather(*tasks, return_exceptions=True) 来收集所有协程的结果，然后逐个检查是否有异常发生。
```

协程 + 子进程 运行shell命令
比threading.Thread + subprocess.run的方式耗时久一点(几秒)，但是运行shell命令越多相对差距越小

```python
import asyncio

async def run_command(cmd):
    # 启动子进程，并将其封装为一个协程
    proc = await asyncio.create_subprocess_shell(cmd, 
                                                 stdout=asyncio.subprocess.PIPE, 
                                                 stderr=asyncio.subprocess.PIPE)
    stdout, stderr = await proc.communicate()
    return stdout.decode('utf-8').strip(), stderr.decode('utf-8').strip()

async def main():
    tasks = [
        run_command('echo 1'),
        run_command('echo 2'),
        run_command('echo 3'),
    ]
    # 等待所有子进程执行完毕，并返回结果
    results = await asyncio.gather(*tasks)
    assert len(results) == len(tasks)

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
```

## tkinter

获取字符串宽度

```python
import tkinter as tk
from tkinter import font

# 创建一个隐藏的 Tkinter 窗口
root = tk.Tk()
# root.withdraw()
# root.quit()
# root.mainloop()

# 打印所有字体名称
for font_family in font.families():
    _font = font.Font(family=font_family)
    # 获取字符串宽度
    width = _font.measure('test')
    print(f'{font_family:40s}', width)
```
